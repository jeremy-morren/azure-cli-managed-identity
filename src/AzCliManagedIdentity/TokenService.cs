using Azure.Identity;

// ReSharper disable MethodHasAsyncOverload

namespace AzCliManagedIdentity;

public class TokenService : ITokenService
{
    /// <summary>
    /// Requests a token using the Azure CLI credential.
    /// </summary>
    /// <remarks>
    /// This method cannot be run in parallel (due to the environment variable)
    /// Shouldn't be a problem for a CGI process
    /// </remarks>
    public async Task<TokenResponse> RequestAzureCliToken(TokenRequest request, CancellationToken ct)
    {
        LogRequest(request);
        // First copy the Azure CLI config files to a temp directory
        using var temp = new TempDirectory();
        CopyFiles(temp.Path);
        WriteWarnings(temp.Path);

        // Set the environment variable to point to the temp directory
        Environment.SetEnvironmentVariable("AZURE_CONFIG_DIR", temp.Path, EnvironmentVariableTarget.Process);

        var options = new AzureCliCredentialOptions()
        {
            ProcessTimeout = GetTimeout()
        };
        var credential = new AzureCliCredential(options);
        var token = await credential.GetTokenAsync(request.CreateTokenRequestContext(), ct);
        var response = new TokenResponse(token);
        LogResponse(response);
        return response;
    }

    private static TimeSpan? GetTimeout()
    {
        var timeout = Environment.GetEnvironmentVariable("AZURE_CLI_TIMEOUT");
        if (double.TryParse(timeout, out var parsedTimeout))
            return TimeSpan.FromSeconds(parsedTimeout);
        return null;
    }

    #region Logging

    private static void LogRequest(TokenRequest request)
    {
        Console.Error.WriteLine($"Requesting token with Azure CLI credential. Resource: {request.Resource}");
    }

    /// <summary>
    /// Writes a log message to stderr about the acquired token.
    /// </summary>
    private static void LogResponse(TokenResponse response)
    {
        var notBefore = DateTimeOffset.FromUnixTimeSeconds(response.NotBefore);
        var expiresAt = DateTimeOffset.FromUnixTimeSeconds(response.ExpiresOn);
        var validFor = expiresAt - notBefore;
        Console.Error.WriteLine(
            $"Acquired token using Azure CLI credential. Resource: {response.Resource}. Valid for: {validFor:g}. Expires At: {expiresAt:yyyy-MM-dd HH:mm:ss zzz}");
    }

    #endregion

    #region Copy Files

    /// <summary>
    /// Copies the required Azure CLI config files to a temporary directory.
    /// </summary>
    public static void CopyFiles(string tempDir)
    {
        // First: Copy generated files from the default Azure CLI config directory
        foreach (var file in GetFiles(GetDefaultConfigDir(), DefaultFilesToCopy))
            Copy.CopyFile(file, tempDir);

        // Then copy the files from the source Azure CLI config directory (i.e. mounted volume)
        var sourceConfig = EnvVariableHelpers.GetValue("SOURCE_AZURE_CONFIG");
        if (!Directory.Exists(sourceConfig))
            throw new DirectoryNotFoundException($"Source Azure CLI config directory not found: '{sourceConfig}'");

        foreach (var file in GetFiles(sourceConfig, SourceFilesToCopy))
            Copy.CopyFile(file, tempDir);
    }

    /// <summary>
    /// Wildcard file names to copy from the default Azure CLI config directory. These are files generated by the Azure CLI itself (run in the container)
    /// </summary>
    private static readonly string[] DefaultFilesToCopy =
    [
        "versionCheck.json",
        "commandIndex.json"
    ];

    /// <summary>
    /// Wildcard file names to copy from the mounted Azure CLI config directory. These are the files required to get a token.
    /// </summary>
    private static readonly string[] SourceFilesToCopy =
    [
        "az.*",
        "azureProfile.json",
        "*config",
        "service_principal_entries.json",
        "msal_http*",
        // Ignore any msal_token*.bin files (which will be encrypted and therefore unreadable by the container)
        "msal_token*.json"
    ];

    private static IEnumerable<string> GetFiles(string directory, string[] patterns) =>
        patterns.SelectMany(pattern => Directory.GetFiles(directory, pattern, SearchOption.TopDirectoryOnly));

    /// <summary>
    /// Returns default Azure CLI config directory (i.e. ~/.azure on Linux or %USERPROFILE%\.azure on Windows).
    /// </summary>
    private static string GetDefaultConfigDir() =>
        Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".azure");

    #endregion

    /// <summary>
    /// Writes warnings to stderr if the Azure CLI config directory is not mounted correctly.
    /// </summary>
    /// <param name="tempDir"></param>
    private static void WriteWarnings(string tempDir)
    {
        // Check for az.json file. If not present, print warning about incorrect volume mount
        var azJsonFile = Path.Combine(tempDir, "az.json");
        if (!File.Exists(azJsonFile))
        {
            Console.Error.WriteLine($$"""
                                      Warning: {{azJsonFile}} not found. Ensure that the Azure CLI config directory is mounted correctly.
                                      Example docker-compose.yml:
                                      services:
                                        managed-identity:
                                          image: jeremysv/azcli-managed-identity
                                          volumes:
                                            - "{USERPROFILE:-~}/.azure:/azureCli:ro"
                                      """);
            return;
        }

        // Check for the msal_token_cache.json file
        var msalTokenCacheFileJson = Path.Combine(tempDir, "msal_token_cache.json");
        if (File.Exists(msalTokenCacheFileJson))
            return;

        // If not present, check if the msal_token_cache.bin file exists. If it is, print a warning about token encryption being enabled
        var msalTokenCacheFileBin = Path.Combine(tempDir, "msal_token_cache.bin");
        if (File.Exists(msalTokenCacheFileBin))
            Console.Error.WriteLine("""
                                    Warning: Token encryption is enabled (default on Windows).
                                    This will cause all token requests to fail. To fix this error, run the following command:
                                    az config set core.encrypt_token_cache=false
                                    See https://github.com/Azure/azure-cli/issues/29193#issuecomment-2174836155
                                    """);
        else
            Console.Error.WriteLine("Warning: msal_token_cache.json not found. Ensure that the Azure CLI config directory is mounted correctly");

    }

}